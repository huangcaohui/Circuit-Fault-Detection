//=======================================================
//file:float_fft.c - Fixed-point in-place Fast Fourier Transform  
//                                        and intverse Transform  
// note: vt[Ndot]---a/d采样取得的输入数字序列 16位无符号整数， 
//                  -32768~32767 （1。15格式 +1~-1），为保持精度，
//                  如A/D位数小于16位，可采用*2^(16-m)处理，（M--A/D位数）
//                  如A/D单端输入（0X0000H~0XFFFFH）将转换结果减去32768
//       Ndot：点数（一个计算周期，数字量化的序列长度）        
//       vx[Ndot]; 输入序列的实部     |     输出谱序列的实部
//       vy[Ndot]; 输入序列的虚部     |     输出谱序列的虚部       
//       vk[Ndot]; 功率谱序列
//-------------------------------------------------------
//
//
//
//
//======================================================= 
#include "floatfft.h"

float vt[Ndot];
float vx[Ndot];
float vy[Ndot];
float vk[Ndot / 2];
u8 NFT;
//---------------------------------------------------------------
//--------------------------------------------------------------- 

void float_fft(float *input_dot, int m)
{
	unsigned int nn, i, i1, i2, j, k, l, l1, l2;
	float tx, ty, t1, t2;
	float *paddress;
	float temp1, temp2;
	float temp0;
	float c1, c2, u1, u2, z, tem;
	float pi = 3.1415926;
	u16 line_num;

	paddress = &input_dot[0];
	nn = 1 << m;
	//========================================
	//  real and image=0
	//========================================
	for (i = 0; i < nn; i++)
	{
		vy[i] = 0;
		vx[i] = *(paddress + i);  //若滤波此句去掉
		//vx[i]/=2;
	}

	//========================================
	//  do bit reversal
	//========================================
	i2 = nn >> 1;
	j = 0;
	for (i = 0; i < nn - 1; i++)
	{
		if (i < j)
		{
			tx = vx[i];
			ty = vy[i];
			vx[i] = vx[j];
			vy[i] = vy[j];
			vx[j] = tx;
			vy[j] = ty;
		}
		k = i2;
		while (k <= j)
		{
			j -= k;
			k >>= 1;
		}
		j += k;
	}

	//=======================================
	//   compute fft
	//=======================================
	l2 = 1;
	for (l = 0; l < m; l++)              //step3
	{
		l1 = l2;
		l2 <<= 1;
		u1 = 1.0;
		u2 = 0.0;
		tem = pi / l1;
		c1 = cosf(tem);
		c2 = sinf(tem);
		for (j = 0; j < l1; j++)         //step2
		{
			for (i = j; i < nn; i += l2)   //step 1
			{
				//--------------- 
				i1 = i + l1;
				//---------------
                //
                //---------------
				t1 = u1 * vx[i1] - u2 * vy[i1];
				t2 = u1 * vy[i1] + u2 * vx[i1];
				//---------------
				//
				//---------------
				vx[i1] = vx[i] - t1;
				vy[i1] = vy[i] - t2;
				vx[i] += t1;
				vy[i] += t2;
				//---------------
				//
				//---------------
			}
			z = u1 * c1 - u2 * c2;
			u2 = u1 * c2 + u2 * c1;
			u1 = z;
		}
	}
	//================================
	// cal. power
	//================================
	line_num = Ndot/2 > 256 ? 256 : Ndot/2;
	for (i = 0; i < line_num; i++)
	{
		temp1 = vx[i];
		temp2 = vy[i];
		temp0 = (temp1*temp1 + temp2 * temp2);
		vk[i] = (sqrt(temp0))/(Ndot/2)*0.00998004;
	}
}
//========================================================
 //========================================================
//    fft反变换
//========================================================
void ifloat_fft(int m)
{
	unsigned int nn, i, i1, i2, j, k, l, l1, l2;
	float tx, ty, t1, t2;
	float c1, c2, u1, u2, z, tem;
	float pi = 3.1415926;
	nn = 1 << m;
	//========================================
	//  real and image /nm
	//========================================
	for (i = 0; i < nn; i++)
	{
		//---------------------
		vx[i] = vx[i] * 2;
		vy[i] = vy[i] * 2;
		//----------------------------------
		// 滤波 均幅放大 等
		//----------------------------------
		/* 例如：保留1ST 3 5次谐波，其余滤出
		if((i==NFT))//|(i==NFT*3)|(i==NFT*5))
		{
		  vx[i]=vx[i] ;
		  vy[i]=vy[i] ;
		}
		else
		{
		  vx[i]=0;
		  vy[i]=0;
		}
		 */
		 //-----------------------------------
	}
	//========================================
	//  do bit reversal
	//========================================
	i2 = nn >> 1;
	j = 0;
	for (i = 0; i < (nn - 1); i++)
	{
		if (i < j)
		{
			tx = vx[i];
			ty = vy[i];
			vx[i] = vx[j];
			vy[i] = vy[j];
			vx[j] = tx;
			vy[j] = ty;
		}
		k = i2;
		while (k <= j)
		{
			j -= k;
			k >>= 1;
		}
		j += k;
	}
	//=======================================
	//   compute fft
	//=======================================
	l2 = 1;
	for (l = 0; l < m; l++)
	{
		l1 = l2;
		l2 <<= 1;
		u1 = 1.0;
		u2 = 0.0;
		tem = pi / l1;
		c1 = cosf(tem);
		c2 = -sinf(tem);
		for (j = 0; j < l1; j++)
		{
			for (i = j; i < nn; i += l2)
			{
				i1 = i + l1;
				//---------------
				//---------------
				t1 = u1 * vx[i1] - u2 * vy[i1];
				t2 = u1 * vy[i1] + u2 * vx[i1];
				//---------------
				//---------------
				vx[i1] = vx[i] - t1;
				vy[i1] = vy[i] - t2;
				//----------------
				vx[i] += t1;
				vy[i] += t2;
				//---------------
				//---------------
			}
			z = u1 * c1 - u2 * c2;
			u2 = u1 * c2 + u2 * c1;
			u1 = z;
		}
	}
}
//========================================================

//========================================================
